public class question_one {
    public static void main(String[] args) {
        new A(new B());
        //B 类继承自 A 类，所以在创建 B 对象时，会首先调用 A 的构造函数。
    }
    //输出为A B A AB
}
class A {
    public A() {
        System.out.println("A");
    }

    public A(B b) {
        this();
        System.out.println("AB");
    }
}

class B extends A {
    public B() {
        System.out.println("B");
    }
}

//继承性的作用：
//继承的出现减少了代码冗余，提高了代码的复用性。
//继承的出现，更有利于功能的扩展。
//继承的出现让类与类之间产生了关系，提供了多态的前提。
//注意：不要仅为了获取其他类中某个功能而去继承。


//一旦子类A继承父类B之后，子类A就获取了父类B中声明的结构：属性、方法；
//特别的：父类中声明为私有的（private）属性和方法
//子类继承父类以后，仍然认为子类获取了父类的结构，只是因为权限修饰符的封装性影响，使得子类不能直接调用继承父类私有的属性和方法；
//在Java 中，继承的关键字用的是extends，即子类不是父类的子集， 而是对父类的扩展。
//Java只支持单继承和多层继承，不允许多重继承(一个类只能有一个父类);

//如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类；
//所有的Java类（除java.lang.Object）都直接或者间接继承于java.lang.Object类；



//子类对象实例化过程理解：
//（1）从结果上来看：（继承性）
//子类继承父类以后，就获取了父类中声明的属性和方法。
//创建子类的对象，在堆空间中，就会加载所有父类中声明的属性；

//当我们通过子类的构造器创建子类对象时，我们一定会直接或者间接的调用其父类的构造器，进而调用父类的父类构造器……；
//直到调用java.lang.Object类中空惨的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
//明确：虽然创建子类对象时，调用了父类的构造器，但是至始至终就创建了一个对象，即为new的子类对象；
